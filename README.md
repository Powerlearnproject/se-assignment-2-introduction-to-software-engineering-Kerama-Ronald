[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-24ddc0f5d75046c5622901739e7c5dd533143b0c8e959d652212380cedb1ea36.svg)](https://classroom.github.com/a/-ucQIGTc)
[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-718a45dd9cf7e7f842a935f5ebbe5719a5e09af4491e668f4dbf3b35d5cca122.svg)](https://classroom.github.com/online_ide?assignment_repo_id=15244531&assignment_repo_type=AssignmentRepo)
# SE-Assignment-2
Assignment: Introduction to Software Engineering
Instructions:
Answer the following questions based on your understanding of software engineering concepts. Provide detailed explanations and examples where appropriate.

Questions:
Define Software Engineering: 
Software engineering is the systematic application of engineering principles,methods,and tools to the development and maintenance of high-quality software systems.

What is software engineering, and how does it differ from traditional programming? 
The main difference between the two roles is that software engineering focuses more broadly on the software, using complex computer science and engineering to construct the structure of the software. Programmers focus only on the technical coding, or writing, of the software itself.

Software Development Life Cycle (SDLC): 
The Software Development Life Cycle (SDLC) is a structured process that enables the production of high-quality, low-cost software, in the shortest possible production time.

Explain the various phases of the Software Development Life Cycle. Provide a brief description of each phase.
1. Planning phase
The planning phase encompasses all aspects of project and product management. This typically includes resource allocation, capacity planning, project scheduling, cost estimation, and provisioning.
2. Coding phase
The coding phase includes system design in an integrated development environment. It also includes static code analysis and code review for multiple types of devices.
3. Building Phase
The building phase takes the code requirements determined earlier and uses those to begin actually building the software.
4. Testing phase 
Assessments entail the performance of functional testing: unit testing, code quality testing, integration testing, system testing, security testing, performance testing and acceptance testing, as well as nonfunctional testing. If a defect is identified, developers are notified. Validated (actual) defects are resolved, and a new version of the software is produced.
5. Release Phase
The release phase involves the team packaging, managing and deploying releases across different environments.
6. Deploy Phase
In the deployment phase, the software is officially released into the production environment. 
7. Operate Phase
The operate phase entails the use of the software in the production environment.
8. Monitor Phase
In the monitor phase, various elements of the software are monitored. These could include the overall system performance, user experience, new security vulnerabilities, an analysis of bugs or errors in the system.

Agile vs. Waterfall Models:
Compare and contrast the Agile and Waterfall models of software development. What are the key differences, and in what scenarios might each be preferred?
Agile is an iterative, incremental, and adaptive approach to software development. Agile teams work in short sprints, typically two to four weeks long, and focus on delivering small, usable pieces of software at the end of each sprint. Agile methodologies, such as Scrum and Kanban, prioritize flexibility, collaboration and customer satisfaction, and are well suited for projects with changing requirements and uncertainty.

Waterfall, on the other hand, is a more traditional, linear approach to software development. In Waterfall, development is divided into distinct phases such as requirements gathering, design, development, testing, and deployment. Each phase must be completed before the next one can begin. Waterfall is known for its well-defined process and is often used in projects where requirements are well-understood and unlikely to change.

Requirements Engineering:

What is requirements engineering? 

Describe the process and its importance in the software development lifecycle.
Requirements Engineering is the process of identifying, eliciting, analyzing, specifying, validating, and managing the needs and expectations of stakeholders for a software system.
It is a four-step process, which includes -
Feasibility Study
Requirement Elicitation and Analysis
Software Requirement Specification
Software Requirement Validation
Software Requirement Management

Software Design Principles:

Explain the concept of modularity in software design. How does it improve maintainability and scalability of software systems?
The modularity simply means the software components that are been created by dividing the software. The software is divided into various components that work together to form a single functioning item but sometimes they can perform as a complete function if not connected with each other.

Testing in Software Engineering:

Describe the different levels of software testing (unit testing, integration testing, system testing, acceptance testing). 
- Acceptance testing: Verifying whether the whole system works as intended.
- Code review: Confirming that new and modified software is following an organization’s coding standards and adheres to its best practices.
- Integration testing: Ensuring that software components or functions operate together.
- Unit testing: Validating that each software unit runs as expected. A unit is the smallest testable component of an application.
- Functional testing: Checking functions by emulating business scenarios, based on functional requirements. Black-box testing is a common way to verify functions.
- Performance testing: Testing how the software runs under different workloads. Load testing, for example, is used to evaluate performance under real-life load conditions.
- Regression testing: Checking whether new features break or degrade functionality. Sanity testing can be used to verify menus, functions and commands at the surface level, when there is no time for a full regression test.
- Security testing: Validating that your software is not open to hackers or other malicious types of vulnerabilities that might be exploited to deny access to your services or cause them to perform incorrectly.
- Stress testing: Testing how much strain the system can take before it fails. Stress testing is considered to be a type of non-functional testing.
- Usability testing: Validating how well a customer can use a system or web application to complete a task.

Why is testing crucial in software development?
When development leaves ample room for testing, it improves software reliability and high-quality applications are delivered with few errors. A system that meets or even exceeds customer expectations leads to potentially more sales and greater market share.

Version Control Systems:

What are version control systems, and why are they important in software development? Give examples of popular version control systems and their features.

Version Control Systems (VCS) are software tools that help in tracking changes made to files and coordinating work among multiple developers. They record changes over time so that specific versions of files can be recalled later. VCS can manage changes to documents, programs, and other information stored as computer files.

Types of Version Control Systems: 
Local Version Control Systems: It is one of the simplest forms and has a database that kept all the changes to files under revision control. RCS is one of the most common VCS tools. It keeps patch sets (differences between files) in a special format on disk. By adding up all the patches it can then re-create what any file looked like at any point in time. 

Centralized Version Control Systems: Centralized version control systems contain just one repository globally and every user need to commit for reflecting one’s changes in the repository. It is possible for others to see your changes by updating. 



Software Project Management:

Discuss the role of a software project manager. What are some key responsibilities and challenges faced in managing software projects?

Main role of software project manager is to execute and supervise the software project life cycle and to ensure that it is working as per desired schedule. Project manager is also responsible for establishing proper coordination between project stakeholders.

Key Challenges 
1. Managing Unclear circumstances 
2. Language barrier
3. Balancing Time, Cost, and Quality

Software Maintenance:

Define software maintenance and explain the different types of maintenance activities. Why is maintenance an essential part of the software lifecycle?
Software maintenance is the process of modifying and updating software applications after their initial deployment to correct faults, improve performance, or adapt to a changing environment.

The purpose of software maintenance is to modify an existing software system cost-effectively while preserving its overall integrity. Software maintenance sustains the operation of a software product throughout its lifetime, deals with changing user needs, and corrects problems discovered after the software has been put into use following initial development and implementation.

1. Preventive Maintenance
Preventive maintenance is aimed at catching and fixing problems before they happen. It is most commonly carried out in the form of regular inspections, usually occurring multiple times per year.

When you inspect a system or a piece of technology, carefully check for all signs of wear, tear or imminent breakdown. Replace damaged parts immediately. This will prevent having to go into “crisis mode” if something breaks unexpectedly.

The primary benefit of preventive maintenance is that it can eliminate unplanned shutdown time as you will ideally catch problems before they occur.

2. Condition-Based Maintenance
Condition-based maintenance is sometimes considered to be a more advanced alternative to preventive maintenance. Rather than being inspected according to a schedule, machines and systems are carefully observed for changes that could indicate upcoming failure.

With condition-based maintenance, technicians observe the system running and identify variables that could affect functioning, like temperature, vibration speed, power, the presence or absence of moisture, and more.

Another strategy within condition-based maintenance is predictive maintenance.

3. Predictive Maintenance
Predictive maintenance refers to a specific type of condition-based maintenance in which systems are constantly observed via sensor devices. These devices are attached to components of the system and feed constant, real-time data to software. The software then interprets this data and warns maintenance technicians of approaching danger.

Predictive maintenance is generally considered to be the most advanced and intensive type of maintenance. This is because there is a lot of data to interpret – and the sensor devices themselves need to be regularly maintained and checked.

4. Corrective Maintenance
Corrective maintenance is initiated when a problem is discovered while working on another work order. With corrective maintenance issues are caught ‘just in time’.

For example, during a scheduled maintenance check or while fixing another issue, a maintenance technician notices that a pipe in a HVAC system is not working as it should. Corrective maintenance is then scheduled for a future date where the problem is repaired or replaced.

Because corrective maintenance issues are found ‘just in time’, it reduces emergency repairs and increases employee safety.

5. Predetermined Maintenance
Unlike other styles, predetermined maintenance is carried out using rules and suggestions created by the original manufacturer, rather than the maintenance team. These suggestions are based on experiments and gathered data.

Ethical Considerations in Software Engineering:

What are some ethical issues that software engineers might face? How can software engineers ensure they adhere to ethical standards in their work?
- Contribute to society and human well-being: This principle emphasizes the positive impact that software engineering can have on society and individuals. It encourages engineers to use their skills for the benefit of humanity.
- Avoid harm to others: Harm can come in many forms, such as physical harm, mental harm, or harm to data and systems. Software engineers should strive to minimize harm caused by their actions or the software they create.
- Be honest and trustworthy: Honesty is a fundamental aspect of ethics. Software engineers should be truthful about their qualifications, capabilities, and the potential impact of their work.



Submission Guidelines:
Your answers should be well-structured, concise, and to the point.
Provide real-world examples or case studies wherever possible.
Cite any references or sources you use in your answers.
Submit your completed assignment by [due date].
